name: Branch Management

on:
  schedule:
    - cron: '0 * * * *' # 毎時0分に実行

  workflow_dispatch:
    inputs:
      base_branch:
        description: 'Base branch to use'
        required: false
        default: 'main'

env:
  BASE_BRANCH: ${{ github.event.inputs.base_branch || 'main' }}
  DELETE_OLD_BRANCHES: 'false'
  BRANCH_STATUS_PATH: 'branch-status.yaml'

jobs:
  create_lock:
    runs-on: [ self-hosted, Linux ]
    if: >-
      ${{
        always()
      }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BASE_BRANCH }}
          fetch-depth: 0

      - name: Create .lock file
        run: |
          if [ -f .lock ]; then
            echo ".lock file already exists. Exiting."
            exit 1
          fi
          touch .lock

      - name: Commit and push .lock file
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          git add .lock
          git commit -m "Lock the repository for automatic branch management" || echo "No changes to commit"
          git push origin $BASE_BRANCH

  extract_old_branches:
    runs-on: [ self-hosted, Linux ]
    if: >-
      ${{
        always()
      }}
    outputs:
      target_branches: ${{ steps.extract_old_branches.outputs.target_branches }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BASE_BRANCH }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm install js-yaml

      - name: Extract Branches
        id: extract_old_branches
        uses: actions/github-script@v6
        with:
          result-encoding: json
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            const branchStatusPath = '${{ env.BRANCH_STATUS_PATH }}';
            const branchStatus = yaml.load(fs.readFileSync(branchStatusPath, 'utf8'));
            if (!branchStatus)
            {
              console.log(`No branch status found in ${branchStatusPath}`);
              return;
            }

            {
              const currentTime = new Date();
              const now = new Date(currentTime.getTime() - (currentTime.getTime() % (60 * 60 * 1000)));
              const oneHourLater = new Date(currentTime.getTime() - (currentTime.getTime() % (60 * 60 * 1000)) + 60 * 60 * 1000);

              const targetBranches = [];

              // branchStatusのキーと値を取得
              for (const baseName in branchStatus) {
                if (!branchStatus.hasOwnProperty(baseName)) {
                  continue;
                }

                const branchName = branchStatus[baseName].branch_name;
                const schedules = branchStatus[baseName].schedules;

                let shouldMerge = false;
                for (const schedule of schedules) {
                  const scheduledTime = new Date(schedule);

                  if (isNaN(scheduledTime)) {
                    console.log(`Invalid schedule: ${schedule}`);
                    continue;
                  }

                  if (now <= scheduledTime && scheduledTime < oneHourLater)
                  {
                    shouldMerge = true;
                    break;
                  }
                }

                if (shouldMerge) {
                  targetBranches.push(branchName);
                }
              }

              core.setOutput('target_branches', JSON.stringify(targetBranches));
            }

      - run: |
          echo "Target branches: ${{ steps.extract_old_branches.outputs.target_branches }}"

  merge_old_branches:
    needs: [ create_lock, extract_old_branches ]
    runs-on: [ self-hosted, Linux ]
    if: >-
      ${{
        always() &&
        needs.create_lock.result == 'success' &&
        needs.extract_old_branches.result == 'success' &&
        needs.extract_old_branches.outputs.target_branches && 
        needs.extract_old_branches.outputs.target_branches != '[]'
      }}
    strategy:
      max-parallel: 1
      matrix:
        branch: ${{ fromJson(needs.extract_old_branches.outputs.target_branches) }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BASE_BRANCH }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm install js-yaml

      - name: Merge Branch
        id: merge_branch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="${{ matrix.branch }}"
          echo "Merging branch: $BRANCH"

          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          # Fetch the branch
          git fetch origin "$BRANCH":"$BRANCH"

          # Attempt to merge
          if git merge --no-ff --no-edit "$BRANCH"; then
            echo "Successfully merged $BRANCH into $BASE_BRANCH."
            echo "merged=true" >> $GITHUB_OUTPUT
          else
            echo "Merge conflict when merging $BRANCH into $BASE_BRANCH. Aborting merge."
            git merge --abort
            echo "merged=false" >> $GITHUB_OUTPUT
          fi

      - name: Update branch-status.yaml
        uses: actions/github-script@v6
        env:
          merged: ${{ steps.merge_branch.outputs.merged }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            const branchStatusPath = '${{ env.BRANCH_STATUS_PATH }}';
            let branchStatus = {};

            if (fs.existsSync(branchStatusPath)) {
              branchStatus = yaml.load(fs.readFileSync(branchStatusPath, 'utf8'));
            }

            const branch = '${{ matrix.branch }}';
            const merged = process.env.merged === 'true';

            for (const baseName in branchStatus)
            {
              if (branchStatus[baseName].branch_name === branch)
              {
                branchStatus[baseName].merged = merged;
                break;
              }
            }

            fs.writeFileSync(branchStatusPath, yaml.dump(branchStatus));

            console.log(`Updated ${branchStatusPath} with merged status for branch ${branch}`);

      - name: Commit and push branch-status.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          git add $BRANCH_STATUS_PATH
          git commit -m "Update $BRANCH_STATUS_PATH with merge result for branch ${{ matrix.branch }}" || echo "No changes to commit"
          git push origin $BASE_BRANCH

  extract_new_branches:
    needs: [ extract_old_branches, merge_old_branches ]
    runs-on: [ self-hosted, Linux ]
    if: >-
      ${{ 
        always() &&
        needs.extract_old_branches.result != 'failure' &&
        needs.merge_old_branches.result != 'failure'
      }}
    outputs:
      new_branches: ${{ steps.extract_new_branches.outputs.new_branches }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BASE_BRANCH }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm install js-yaml

      - name: Extract New Branches
        id: extract_new_branches
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: json
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            const branchStatusPath = '${{ env.BRANCH_STATUS_PATH }}';
            const branchStatus = yaml.load(fs.readFileSync(branchStatusPath, 'utf8'));
            if (!branchStatus)
            {
              console.log(`No branch status found in ${branchStatusPath}`);
              return;
            }

            const newBranches = [];
            for (const baseName in branchStatus)
            {
              const type = branchStatus[baseName].type;
              const merged = branchStatus[baseName].merged;

              const existed = branchStatus[baseName].hasOwnProperty('branch_name');

              // 元から存在しなかったか、マージが成功したブランチに対してのみ新しいブランチを作成
              if (!existed || merged)
              {
                let nextNumber = 1;
                if (existed)
                {
                  const branchName = branchStatus[baseName].branch_name;

                  const eReg = new RegExp(`^${baseName}/\\w+-(\\d+)$`);
                  nextNumber = parseInt(branchName.match(eReg)[1]) + 1;
                }

                newBranches.push(`${baseName}/${type}-${nextNumber}`);
              }
            }

            core.setOutput('new_branches', JSON.stringify(newBranches));

      - run: |
          echo "New branches after filtering: ${{ steps.extract_new_branches.outputs.new_branches }}"

  update_branch_status:
    needs: [ merge_old_branches, extract_new_branches ]
    runs-on: [ self-hosted, Linux ]
    if: >-
      ${{
        always() &&
        needs.merge_old_branches.result != 'failure' &&
        needs.extract_new_branches.result == 'success' &&
        needs.extract_new_branches.outputs.new_branches && 
        needs.extract_new_branches.outputs.new_branches != '[]'
      }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BASE_BRANCH }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm install js-yaml

      - name: Check and Update ${{ env.BRANCH_STATUS_PATH }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            const branchStatusPath = '${{ env.BRANCH_STATUS_PATH }}';

            // Load existing ${{ env.BRANCH_STATUS_PATH }} if it exists
            let branchStatus = {};
            if (fs.existsSync(branchStatusPath))
            {
              branchStatus = yaml.load(fs.readFileSync(branchStatusPath, 'utf8'));
            }

            const newBranches = JSON.parse('${{ needs.extract_new_branches.outputs.new_branches }}');

            const currentTime = new Date();
            const now = new Date(currentTime.getTime() - (currentTime.getTime() % (60 * 60 * 1000)));

            const currentTimeString = currentTime.toISOString();
            const oneHourLater = new Date(currentTime.getTime() - (currentTime.getTime() % (60 * 60 * 1000)) + 60 * 60 * 1000);

            const oneHourLaterString = oneHourLater.toISOString();

            for (const baseName in branchStatus)
            {
              const newBranch = newBranches.find(b => b.startsWith(baseName));
              if (newBranch)
              {
                const oldBranch = branchStatus[baseName].branch_name;

                branchStatus[baseName].branch_name = newBranch;
                branchStatus[baseName].timestamp = currentTimeString;
                delete branchStatus[baseName].merged;

                if (oldBranch)
                {
                  console.log(`Updated branch for \`${baseName}\` from \`${oldBranch}\` to \`${newBranch}\``);
                }
                else
                {
                  console.log(`Created branch for \`${baseName}\` as \`${newBranch}\``);
                }
              }

              let schedules = branchStatus[baseName].schedules;
              const originalLength = schedules.length;

              // 古くなったスケジュールを削除
              schedules = schedules.filter(schedule => now <= new Date(schedule));

              if (schedules.length !== originalLength)
              {
                console.log(`Removed schedules older than one day for ${baseName}`);
              }

              // 失敗したブランチに対してリトライをスケジュール
              if (branchStatus[baseName].hasOwnProperty('merged') && !branchStatus[baseName].merged)
              {
                if (!schedules.includes(oneHourLaterString))
                {
                  schedules.push(oneHourLaterString);
                  console.log(`Scheduled retry for ${baseName} at ${oneHourLaterString}`);
                }
                else
                {
                  console.log(`Retry already scheduled for ${baseName} at ${oneHourLaterString}`);
                }
              }

              // スケジュールを時間順にソート
              schedules.sort((a, b) => new Date(a) - new Date(b));

              branchStatus[baseName].schedules = schedules;
            }

            fs.writeFileSync(branchStatusPath, yaml.dump(branchStatus));

            console.log(`Updated ${branchStatusPath}`);

      - name: Commit and Push ${{ env.BRANCH_STATUS_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          git add $BRANCH_STATUS_PATH
          git commit -m "Update $BRANCH_STATUS_PATH for new branches" || echo "No changes to commit"
          git push origin $BASE_BRANCH

  yield_new_branches:
    needs: [ extract_new_branches, update_branch_status ]
    runs-on: [ self-hosted, Linux ]
    if: >-
      ${{
        always() &&
        needs.extract_new_branches.result == 'success' &&
        needs.extract_new_branches.outputs.new_branches && 
        needs.extract_new_branches.outputs.new_branches != '[]' &&
        needs.update_branch_status.result != 'failure'
      }}
    strategy:
      max-parallel: 1
      fail-fast: false
      matrix:
        branch: ${{ fromJson(needs.extract_new_branches.outputs.new_branches) }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BASE_BRANCH }}
          fetch-depth: 0

      - name: Create new branch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="${{ matrix.branch }}"
          echo "Creating new branch: $BRANCH"

          # Gitの設定
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          # 最新のBASE_BRANCHを取得
          git checkout $BASE_BRANCH
          git pull origin $BASE_BRANCH

          # 新しいブランチを作成
          git checkout -b "$BRANCH"
          git commit --allow-empty -m "Create $BRANCH branch"
          git push origin "$BRANCH"
          
  delete_lock:
    runs-on: [ self-hosted, Linux ]
    needs: yield_new_branches
    if: >-
      ${{
        always()
      }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BASE_BRANCH }}
          fetch-depth: 0

      - name: Delete .lock file
        run: |
          rm -f .lock

      - name: Commit and push .lock file deletion
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          git add .lock
          git commit -m "Unlock the repository after automatic branch management" || echo "No changes to commit"
          git push origin $BASE_BRANCH
