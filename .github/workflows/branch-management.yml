name: Branch Management

on:
  schedule:
    - cron: '0 * * * *' # 毎時0分に実行

  workflow_dispatch:

jobs:
  protect_main_branch:
    runs-on: [ self-hosted, Linux ]
    if: |
      ${{
        always()
      }}
    steps:
      - name: Protect main branch
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.BRANCH_MANAGE_TOKEN }}
          script: |
            await github.rest.repos.updateBranchProtection({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: 'main',
              required_status_checks: {
                strict: true,
                contexts: []
              },
              enforce_admins: true,
              required_pull_request_reviews: {
                dismiss_stale_reviews: true
              },
              restrictions: null
            });

  extract_old_branches:
    runs-on: [ self-hosted, Linux ]
    if: |
      ${{
        always()
      }}
    outputs:
      old_branches: ${{ steps.extract_old_branches.outputs.old_branches }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm install js-yaml

      - name: Extract Branches
        id: extract_old_branches
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.BRANCH_MANAGE_TOKEN }}
          result-encoding: json
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            const config = yaml.load(fs.readFileSync('config.yaml', 'utf8'));
            const currentTime = new Date();

            const { data: branches } = await github.rest.repos.listBranches({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            const oldBranches = [];

            for (const branchConfig of config.branches) {
              const baseName = branchConfig.name;
              const schedule = branchConfig.schedule;

              let shouldMerge = false;
              for (const scheduledTime of schedule) {
                const scheduledDate = new Date(scheduledTime);

                if (isNaN(scheduledDate)) {
                  console.log(`Invalid scheduledTime: ${scheduledTime}`);
                  continue;
                }

                const timeDiff = currentTime.getTime() - scheduledDate.getTime();

                if (0 <= timeDiff && timeDiff < 60 * 60 * 1000) {
                  shouldMerge = true;
                  break;
                }
              }

              if (!shouldMerge) {
                continue;
              }

              const branchPattern = new RegExp(`^${baseName}/\\w+-\\d+$`);

              for (const branch of branches) {
                if (branch.name.match(branchPattern)) {
                  oldBranches.push(branch.name);
                }
              }
            }

            core.setOutput('old_branches', JSON.stringify(oldBranches));

      - run: |
          echo "Old branches: ${{ steps.extract_old_branches.outputs.old_branches }}"

  merge_old_branches:
    needs: [ protect_main_branch, extract_old_branches ]
    runs-on: [ self-hosted, Linux ]
    if: |
      ${{
        needs.protect_main_branch.result == 'success' &&
        needs.extract_old_branches.result == 'success' &&
        needs.extract_old_branches.outputs.old_branches != '[]'
      }}
    outputs:
      merged_base_names: ${{ steps.merge_branches.outputs.merged_base_names }}
      failed_base_names: ${{ steps.merge_branches.outputs.failed_base_names }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Merge Branches Sequentially
        id: merge_branches
        env:
          GITHUB_TOKEN: ${{ secrets.BRANCH_MANAGE_TOKEN }}
        continue-on-error: true
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          OLD_BRANCHES='${{ needs.extract_old_branches.outputs.old_branches }}'
          BRANCHES=$(echo "$OLD_BRANCHES" | jq -r '.[]')

          # 最新のmainを取得
          git checkout main
          git pull origin main

          MERGED_BASE_NAMES=()
          FAILED_BASE_NAMES=()

          for BRANCH in $BRANCHES; do
            echo ""
            echo ""
            echo ""
            echo "Processing branch: $BRANCH"

            BASE_NAME=$(echo "$BRANCH" | sed -E 's|/[^/]+$||')

            # 対象のブランチをフェッチ
            git fetch origin "$BRANCH":"$BRANCH"

            # ブランチをマージ
            if git merge --no-ff --no-edit "$BRANCH"; then
              echo "Successfully merged $BRANCH into main."

              git push origin main
              git branch -d "$BRANCH"
              git push origin --delete "$BRANCH"

              MERGED_BASE_NAMES+=("$BASE_NAME")
            else
              echo "Merge conflict when merging $BRANCH into main. Aborting merge."

              git merge --abort
              FAILED_BASE_NAMES+=("$BASE_NAME")
            fi
          done

          if [ ${#MERGED_BASE_NAMES[@]} -eq 0 ]; then
            echo "merged_base_names=[]" >> $GITHUB_OUTPUT
          else
            echo "merged_base_names=$(printf '%s\n' "${MERGED_BASE_NAMES[@]}" | jq -R | jq -s | jq -c 'unique')" >> $GITHUB_OUTPUT
          fi

          if [ ${#FAILED_BASE_NAMES[@]} -eq 0 ]; then
            echo "failed_base_names=[]" >> $GITHUB_OUTPUT
          else
            echo "failed_base_names=$(printf '%s\n' "${FAILED_BASE_NAMES[@]}" | jq -R | jq -s | jq -c 'unique')" >> $GITHUB_OUTPUT
          fi

      - run: |
          echo "Merged base names: ${{ steps.merge_branches.outputs.merged_base_names }}"
          echo "Failed base names: ${{ steps.merge_branches.outputs.failed_base_names }}"

      - uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm install js-yaml

      - name: Re-Schedule
        id: re_schedule
        if: ${{ always() }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.BRANCH_MANAGE_TOKEN }}
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            const path = 'config.yaml';

            // config.yaml を読み込む
            let config = {};
            if (fs.existsSync(path))
            {
              config = yaml.load(fs.readFileSync(path, 'utf8'));
            }
            else
            {
              throw new Error('config.yaml が存在しません。');
            }

            const failedBaseNames = JSON.parse('${{ steps.merge_branches.outputs.failed_base_names }}');

            const currentTime = new Date();
            const oneHourLater = new Date(currentTime.getTime() - (currentTime.getTime() % (60 * 60 * 1000)) + 60 * 60 * 1000).toISOString();
            const oneDayAgo = new Date(currentTime.getTime() - (currentTime.getTime() % (60 * 60 * 1000)) - (24 * 60 * 60 * 1000)).toISOString();

            let modified = false;

            for (const branchConfig of config.branches)
            {
              if (failedBaseNames.includes(branchConfig.name))
              {
                // 1日前以上の古いスケジュールを削除
                const originalLength = branchConfig.schedule.length;
                branchConfig.schedule = branchConfig.schedule.filter(scheduleTime => new Date(scheduleTime) - new Date(oneDayAgo) >= 0);
                if (branchConfig.schedule.length !== originalLength)
                {
                  modified = true;
                  console.log(`Removed schedules older than one day for ${branchConfig.name}`);
                }

                // 新しいスケジュールを追加（重複チェック）
                if (!branchConfig.schedule.includes(oneHourLater))
                {
                  branchConfig.schedule.push(oneHourLater);
                  console.log(`Scheduled retry for ${branchConfig.name} at ${oneHourLater}`);
                  modified = true;
                }
                else
                {
                  console.log(`Retry already scheduled for ${branchConfig.name} at ${oneHourLater}`);
                }

                // スケジュールを時間順にソート
                branchConfig.schedule.sort((a, b) => new Date(a) - new Date(b));
              }
            }

            if (modified)
            {
              fs.writeFileSync(path, yaml.dump(config));
            }

            core.setOutput('config_modified', modified ? 'true' : 'false');  // 変更があったかを出力

      - name: Commit and push config.yaml
        if: ${{ steps.re_schedule.outputs.config_modified == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.BRANCH_MANAGE_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          git add config.yaml
          git commit -m "Update config.yaml for re-scheduling" || echo "No changes to commit"
          git push origin main

  extract_new_branches:
    needs: [ merge_old_branches ]
    runs-on: [ self-hosted, Linux ]
    if: |
      ${{ 
        needs.merge_old_branches.result == 'success'
      }}
    outputs:
      new_branches: ${{ steps.extract_new_branches.outputs.new_branches }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm install js-yaml

      - name: Extract New Branches
        id: extract_new_branches
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.BRANCH_MANAGE_TOKEN }}
          result-encoding: json
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            const config = yaml.load(fs.readFileSync('config.yaml', 'utf8'));
            const currentTime = new Date();

            const { data: branches } = await github.rest.repos.listBranches({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            const newBranches = [];

            // Get merged_base_names from job outputs
            const mergedBaseNames = JSON.parse('${{ needs.merge_old_branches.outputs.merged_base_names }}');

            for (const branchConfig of config.branches)
            {
              const baseName = branchConfig.name;

              // マージが成功したブランチに対してのみ新しいブランチを作成
              if (mergedBaseNames.includes(baseName))
              {
                // 既存のブランチから最大番号を取得
                const existingNumbers = branches
                  .filter(b => b.name.startsWith(`${baseName}/${branchConfig.status}-`))
                  .map(b => parseInt(b.name.split(`${baseName}/${branchConfig.status}-`)[1], 10))
                  .filter(n => !isNaN(n));

                // 最終番号を取得またはリセット
                let nextNumber = 1;
                if (existingNumbers.length > 0) {
                  nextNumber = Math.max(...existingNumbers) + 1;
                }

                newBranches.push(`${baseName}/${branchConfig.status}-${nextNumber}`);
              }
            }

            core.setOutput('new_branches', JSON.stringify(newBranches));

      - run: |
          echo "New branches after filtering: ${{ steps.extract_new_branches.outputs.new_branches }}"

  update_branch_status:
    needs: [ extract_new_branches ]
    runs-on: [ self-hosted, Linux ]
    if: |
      ${{
        needs.extract_new_branches.outputs.new_branches != '[]'
      }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm install js-yaml

      - name: Check and Update branch-status.yaml
        id: check_update_status
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.BRANCH_MANAGE_TOKEN }}
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            const path = 'branch-status.yaml';

            // Load existing branch-status.yaml if it exists
            let branchStatus = {};
            if (fs.existsSync(path))
            {
              branchStatus = yaml.load(fs.readFileSync(path, 'utf8'));
            }

            // Get new branches from job outputs
            const newBranches = JSON.parse('${{ needs.extract_new_branches.outputs.new_branches }}');

            let updated = false;
            const currentTime = new Date().toISOString();

            for (const branch of newBranches)
            {
              const baseName = branch.replace(/\/[^/]+$/, '');
              if (!branchStatus[baseName])
              {
                branchStatus[baseName] = {
                  branch_name: branch,
                  timestamp: currentTime
                };
                updated = true;
                console.log(`Added entry for branch: ${branch}`);
              }
            }

            if (updated)
            {
              fs.writeFileSync(path, yaml.dump(branchStatus));
              core.setOutput('updated', 'true');
            }
            else
            {
              console.log('No updates required for branch-status.yaml');
              core.setOutput('updated', 'false');
            }

      - name: Commit and Push branch-status.yaml
        if: ${{ steps.check_update_status.outputs.updated == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.BRANCH_MANAGE_TOKEN }}
        run: |
          #!/bin/bash
          set -e

          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          git add branch-status.yaml
          git commit -m "Add entries to branch-status.yaml for new branches"

          git push origin main

  yield_new_branches:
    needs: [ extract_new_branches, update_branch_status ]
    runs-on: [ self-hosted, Linux ]
    if: |
      ${{
        needs.extract_new_branches.result == 'success' &&
        needs.extract_new_branches.outputs.new_branches != '[]' &&
        needs.update_branch_status.result == 'success'
      }}
    strategy:
      fail-fast: false
      matrix:
        branch: ${{ fromJson(needs.extract_new_branches.outputs.new_branches) }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm install js-yaml

      - name: Create new branch
        env:
          GITHUB_TOKEN: ${{ secrets.BRANCH_MANAGE_TOKEN }}
        run: |
          #!/bin/bash
          set -e

          BRANCH="${{ matrix.branch }}"
          echo "Creating new branch: $BRANCH"

          # Gitの設定
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          # 最新のmainを取得
          git checkout main
          git pull origin main

          # 新しいブランチを作成
          git checkout -b "$BRANCH"

      - name: Update branch-status.yaml
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.BRANCH_MANAGE_TOKEN }}
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            const path = 'branch-status.yaml';
            const branch = '${{ matrix.branch }}';
            const baseName = branch.replace(/\/[^/]+$/, '');
            const currentTime = new Date().toISOString();

            let branchStatus = {};
            if (fs.existsSync(path)) {
              branchStatus = yaml.load(fs.readFileSync(path, 'utf8'));
            }

            branchStatus[baseName] = {
              branch_name: branch,
              timestamp: currentTime
            };

            fs.writeFileSync(path, yaml.dump(branchStatus));

            console.log(`Updated ${path}`);

      - name: Commit and push changes
        env:
          GITHUB_TOKEN: ${{ secrets.BRANCH_MANAGE_TOKEN }}
        run: |
          BRANCH="${{ matrix.branch }}"

          git add branch-status.yaml
          git commit -m "Update branch-status.yaml for $BRANCH"
          git push origin "$BRANCH"

  unprotect_main_branch:
    runs-on: [ self-hosted, Linux ]
    needs: yield_new_branches
    if: |
      ${{
        always()
      }}
    steps:
      - name: Remove branch protection from main
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.BRANCH_MANAGE_TOKEN }}
          script: |
            await github.rest.repos.deleteBranchProtection({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: 'main'
            });

